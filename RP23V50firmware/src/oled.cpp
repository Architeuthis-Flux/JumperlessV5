#include "oled.h"
#include "configManager.h"
#include "PersistentStuff.h"
#include "LEDs.h"
#include "MatrixState.h"
#include "Probing.h"
#include "Apps.h"
#include "Adafruit_GFX.h"
#include "Adafruit_SSD1306.h"
#include "Wire.h"
#include "Peripherals.h"
#include "RotaryEncoder.h"
#include "config.h"
#include "CH446Q.h"
#include "Commands.h"
#include "FileParsing.h"
#include "ArduinoStuff.h"
#include <cstdarg>
#include <cstdio>
#include <cstring>

//#include <Jokerman8pt7b.h>
#include "Adafruit_GFX.h"
bool oledConnected = false;

// On an arduino LEONARDO:   2(SDA),  3(SCL), ...
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels


Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire1, OLED_RESET);

//display.begin(SSD1306_SWITCHCAPVCC, address);

#define NUMFLAKES     10 // Number of snowflakes in the animation example

#define LOGO_HEIGHT  32
#define LOGO_WIDTH   64

int oledAddress = -1;

// Global instance
class oled oled;

oled::oled() {}

int oled::init() {
    if (jumperlessConfig.top_oled.enabled == 0) {
        return 0;
    }
    int success = 0;
    address = jumperlessConfig.top_oled.i2c_address;
    sda_pin = jumperlessConfig.top_oled.sda_pin;
    scl_pin = jumperlessConfig.top_oled.scl_pin;
    sda_row = jumperlessConfig.top_oled.sda_row;
    scl_row = jumperlessConfig.top_oled.scl_row;
    success = connect();

    if (checkConnection() == false) {
        oledConnected = false;
        disconnect();
       // refreshConnections(-1, 0, 0);
        return 0;
    }
    ///delay(10);
    display.begin(SSD1306_SWITCHCAPVCC, address, false, false);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(3, 3);
    display.invertDisplay(false);
    display.setFont(currentFont);    
    display.clearDisplay();
    display.drawBitmap(0, 0, jogo32h, 128, 32, SSD1306_WHITE);
    display.display();
    Wire1.setTimeout(25);
    charPos = 0;
    // display.drawBitmap(0, 0, jogo32h, 128, 32, SSD1306_WHITE);
    // display.display();
    // display.clearDisplay();
    // display.print("Fuck");
    // display.display();

    // display.drawBitmap(0, 0, jogo32h, 128, 32, 1);
    // display.display();
    //oledTest();
    return success;
}

void oled::test() {
    display.clearDisplay();
   // display.setTextSize(2);
    display.setTextColor(SSD1306_WHITE);
    display.setTextSize(2);
    display.setCursor(2, 1);
    display.print("Fuck");
    display.display();
    display.invertDisplay(true);
    delay(1000);
    //display.display();
    display.clearDisplay();
    display.setTextSize(3);
    display.setCursor(2, 1);
    display.print("Fuck");
    display.display();
    display.invertDisplay(false);
    delay(1000);
    display.display();
    display.clearDisplay();
    display.drawBitmap(0, 0, jogo32h, 128, 32, SSD1306_WHITE);
    display.display();
    oledTest(sda_row, scl_row, sda_pin, scl_pin, 1);
}

// Helper to get current font height
int getFontHeight(const GFXfont* font) {
    if (!font) return 8; // Default font height
    return font->yAdvance;
}

// Helper to check I2C communication with Wire1
bool oled::checkConnection(void) {
    if (jumperlessConfig.top_oled.enabled == 0) {
        oledConnected = false;
        return false;
    }
    if (millis() - lastConnectionCheck > 1000) {
        Wire1.beginTransmission(address);
    
        if (Wire1.endTransmission() != 0) {
           // Serial.println("oled connection lost");
            lastConnectionCheck = millis();
            oledConnected = false;
          //  disconnect();
            return false;
        }
        lastConnectionCheck = millis();
        oledConnected = true;
    }
    return true;
}

int oled::clearPrintShow(const char* c, int size, int x_pos, int y_pos, bool clear, bool show, bool center) {
    if (oledConnected == false) {
        return 0;
    }


    if (clear) {
        charPos = 0;
        display.clearDisplay();
    }
    int strLen = strlen(c);
    int charWidth = 6 * size;
    int displayWidth = display.width();
    int displayHeight = display.height();
    int textPixelWidth = strLen * charWidth;
    int fontHeight = getFontHeight(currentFont);

    // Check if text fits, else look for capital letter to split
    bool split = false;
    int splitIdx = -1;

        if (textPixelWidth > displayWidth && strLen > 2) {
        // Look for a capital letter in the middle (not first or last char)
        for (int i = 1; i < strLen - 1; ++i) {
            
            if (c[i] == ' ' || c[i] == '\0' || c[i] == '\n' || c[i] == '\r' || c[i] == '\t' ) { //first look for a space or other non-letter character
        
                    split = true;
                    splitIdx = i;
                    break;
                }
            }
        }

        if (splitIdx == -1) {


    if (textPixelWidth > displayWidth && strLen > 2) {
        // Look for a capital letter in the middle (not first or last char)
        for (int i = 1; i < strLen - 1; ++i) {

            if (c[i] >= 'A' && c[i] <= 'Z') {
        
                    split = true;
                    splitIdx = i;
                    break;
                }
            }
        }
    }

    if (split) {
        // Split string at splitIdx
        String first = String(c).substring(0, splitIdx);
        String second = String(c).substring(splitIdx);
        // Center vertically: total height = 2 lines * fontHeight
        int totalHeight = 2 * fontHeight;
        int y_start = (displayHeight - totalHeight) / 2;
        if (y_start < 0) y_start = 0;
        // Center and print first line
        int firstLen = first.length();
        int firstPixelWidth = firstLen * charWidth;
        int nudge1 = 0;
        if (center && firstPixelWidth < displayWidth) {
            nudge1 = (displayWidth - firstPixelWidth) / (2 * charWidth);
        }
        char shift1[40] = "                                     ";
        shift1[nudge1] = '\0';
        display.setTextSize(size);
        display.setCursor(x_pos, y_start + fontHeight - 1); // Top align
        display.print(String(shift1) + first);
        // Center and print second line
        int secondLen = second.length();
        int secondPixelWidth = secondLen * charWidth;
        int nudge2 = 0;
        if (center && secondPixelWidth < displayWidth) {
            nudge2 = (displayWidth - secondPixelWidth) / (2 * charWidth);
        }
        char shift2[40] = "                                     ";
        shift2[nudge2] = '\0';
        display.setCursor(x_pos, y_start + fontHeight + fontHeight ); // Next line, top align
        display.print(String(shift2) + second);
        if (show) {
            display.display();
        }
        charPos += strLen;
        return 1;
    }

    // Reduce text size if needed to fit
    while (textPixelWidth > displayWidth && size > 1) {
        size--;
        charWidth = 6 * size;
        textPixelWidth = strLen * charWidth;
        Serial.println(textPixelWidth);
        Serial.println(size);
    }
    int nudge = 0;
    if (center) {
        if (textPixelWidth < displayWidth) {
            nudge = (displayWidth - textPixelWidth) / (2 * charWidth);
        } else {
            nudge = 0;
        }
    }
    display.setTextSize(size);
    display.setCursor(x_pos, y_pos + fontHeight - 1); // Top align
    char shift[40] = "                                     "; // up to 40 spaces
    shift[charPos + nudge] = '\0';
    display.print(String(shift) + String(c));
    charPos += strLen;
    if (show) {
        display.display();
    }
    return 1;
}

void oled::clearPrintShow(String s, int textSize, int x_pos, int y_pos, bool clear, bool show, bool center) {
    if (oledConnected == false) {
        return;
    }
    clearPrintShow(s.c_str(), textSize, x_pos, y_pos, clear, show, center);
}

// void oled::printf(const char* format, ...) {
//     if (oledConnected == false) {
//         return;
//     }
//     char buf[128];
//     va_list args;
//     va_start(args, format);
//     vsnprintf(buf, sizeof(buf), format, args);
//     va_end(args);
//     display.print(buf);
// }

// void oled::clrPrintfsh(const String& msg) {
//     if (!oledConnected) {
//         return;
//     }
//     display.clearDisplay();
//     display.setCursor(2, 2);
//     display.print(msg);
//     display.display();
// }
void oled::print(const char* s) {
    if (oledConnected == false) {
        return;
    }
    display.print(s);
    charPos += strlen(s);
   // display.display();
}

void oled::print(const char* s, int position) {
    if (oledConnected == false) {
        return;
    }
    display.setCursor(position, display.getCursorY());
    display.print(s);
}

void oled::print(int i) {
    if (oledConnected == false) {
        return;
    }
    display.print(i);
    charPos += String(i).length();
   // display.display();
}

void oled::print(const char c) {
    if (oledConnected == false) {
        return;
    }
    display.print(c);
    charPos += 1;
   // display.display();
}

void oled::print(const char c, int position) {
    if (oledConnected == false) {
        return;
    }
    display.setCursor(position, 0);
    display.print(c);
    charPos += 1;
   // display.display();
}

void oled::println(const char* s) {
    if (oledConnected == false) {
        return;
    }
    print(s);
    print("\n");
}

void oled::println(const char c) {
    if (oledConnected == false) {
        return;
    }
    print(c);
    print("\n");
}



void oled::displayBitmap(int x, int y, const unsigned char* bitmap, int width, int height) {
    if (oledConnected == false) {
        return;
    }
    display.drawBitmap(x, y, bitmap, width, height, SSD1306_WHITE);
}

void oled::showJogo32h() {
    if (oledConnected == false) {
        return;
    }
    display.clearDisplay();
    display.drawBitmap(0, 0, jogo32h, 128, 32, SSD1306_WHITE);
    display.display();
}

void oled::clear() {
    if (oledConnected == false) {
        charPos = 0;
        return;
    }
    charPos = 0;
    display.clearDisplay();
    display.setCursor(0, getFontHeight(currentFont));

   // display.display();
}

void oled::fullClear() {
    if (oledConnected == false) {
        return;
    }
    charPos = 0;

    display.~Adafruit_SSD1306();
    delay(10);
    display.begin(SSD1306_SWITCHCAPVCC, address, false, false);
    delay(10);
    display.clearDisplay();
    display.display();
}
void oled::setCursor(int x, int y) {
    if (oledConnected == false) {
        return;
    }
    display.setCursor(x, y);
}

void oled::setTextColor(uint32_t color) {
    if (oledConnected == false) {
        return;
    }
    display.setTextColor(color);
}

void oled::setTextSize(uint8_t size) {
    if (oledConnected == false) {
        return;
    }
    display.setTextSize(size);
}

void oled::setTextWrap(bool wrap) {
    if (oledConnected == false) {
        return;
    }
    display.setTextWrap(wrap);
}

void oled::setRotation(uint8_t rotation) {
    if (oledConnected == false) {
        return;
    }
    display.setRotation(rotation);
}

void oled::setContrast(uint8_t contrast) {
    if (oledConnected == false) {
        return;
    }
    display.ssd1306_command(SSD1306_SETCONTRAST);
    display.ssd1306_command(contrast);
}

void oled::show() {
    if (oledConnected == false) {
        return;
    }
    display.display();
}

bool oled::isConnected() const {
    return oledConnected;
}

void oled::sendCommand(uint8_t cmd) {
    if (oledConnected == false) {
        return;
    }
    display.ssd1306_command(cmd);
}

void oled::invertDisplay(bool inv) {
    if (oledConnected == false) {
        return;
    }
    display.invertDisplay(inv);
}

int oled::connect(void) {
    if (jumperlessConfig.top_oled.enabled == 0) {
        return 0;
    }
    int found = -1;
    gpioNet[jumperlessConfig.top_oled.gpio_sda - 20] = -2;
    gpioNet[jumperlessConfig.top_oled.gpio_scl - 20] = -2;
    removeBridgeFromNodeFile(jumperlessConfig.top_oled.gpio_sda, -1, netSlot, 0);
    removeBridgeFromNodeFile(jumperlessConfig.top_oled.gpio_scl, -1, netSlot, 0);
    addBridgeToNodeFile(jumperlessConfig.top_oled.gpio_sda, jumperlessConfig.top_oled.sda_row, netSlot, 0, 0);
    addBridgeToNodeFile(jumperlessConfig.top_oled.gpio_scl, jumperlessConfig.top_oled.scl_row, netSlot, 0, 0);
    refreshConnections(-1, 0, 0);
    waitCore2();
    found = initI2C(jumperlessConfig.top_oled.sda_pin, jumperlessConfig.top_oled.scl_pin, 100000);
    //scanI2CAddresses(jumperlessConfig.top_oled.i2c_address);
    //delay(100);
    //address = findI2CAddress(jumperlessConfig.top_oled.sda_pin, jumperlessConfig.top_oled.scl_pin, 1);
    // waitCore2();
    gpioNet[jumperlessConfig.top_oled.gpio_sda - 20] = -2;
    gpioNet[jumperlessConfig.top_oled.gpio_scl - 20] = -2;
    gpioState[jumperlessConfig.top_oled.gpio_sda - 20] = 6;
    gpioState[jumperlessConfig.top_oled.gpio_scl - 20] = 6;
    // delay(10);
    // Serial.print("oled Address: ");
    // Serial.println(address, HEX);
    // if (address != -1) {
    //     found = 1;
    //     connected = true;
    // } else {
    //     connected = false;
    //     found = 0;
    //     //disconnect();
    // }

    // oledTest();
    if (found == -1) {
        oledConnected = false;
        return 0;
    } else {
        oledConnected = true;
        return found;
    }
}

void oled::disconnect(void) {
    if (jumperlessConfig.top_oled.enabled == 0) {
        return;
    }
    removeBridgeFromNodeFile(jumperlessConfig.top_oled.gpio_sda, jumperlessConfig.top_oled.sda_row, netSlot, 0);
    removeBridgeFromNodeFile(jumperlessConfig.top_oled.gpio_scl, jumperlessConfig.top_oled.scl_row, netSlot, 0);
    gpioNet[jumperlessConfig.top_oled.gpio_sda - 20] = -1;
    gpioNet[jumperlessConfig.top_oled.gpio_scl - 20] = -1;
    gpioState[jumperlessConfig.top_oled.gpio_sda - 20] = 4;
    gpioState[jumperlessConfig.top_oled.gpio_scl - 20] = 4;
    oledConnected = false;
    refreshConnections(-1, 0, 0);
}

int initOLED(void) {
    return oled.init();
}



// void scanI2CAddresses(int startAddress) {
//     Serial.println("Scanning I2C bus...");
//     int foundAddresses[128];
//     int foundCount = 0;
//     for (int address = startAddress; address <= 0x7F; address++) {
//         Wire1.beginTransmission(address);
//         if (Wire1.endTransmission() == 0) {
//             foundAddresses[foundCount++] = address;
//         }
//     }
//     if (foundCount > 0) {
//         Serial.print("Found I2C devices at: ");
//         for (int i = 0; i < foundCount; i++) {
//             Serial.print("0x");
//             Serial.print(foundAddresses[i], HEX);
//             if (i < foundCount - 1) Serial.print(", ");
//         }
//         Serial.println();
//     } else {
//         Serial.println("No I2C devices found.");
//     }
//     Serial.println("Scan complete.");
// }




int oledTest(int sdaRow, int sclRow, int sdaPin, int sclPin, int leaveConnections) {
    //oled.init();
    oled.clear();
    // oled.setTextColor(SSD1306_WHITE);
    // oled.displayBitmap(0, 0, jogo32h, 128, 32);
    // oled.show();
    int delayTime = 8000;
    //delay(1000);
    resetEncoderPosition = true;
    long lastEncoderPosition = 0;
    oled.setTextSize(4);


    while (1) {
        if (encoderPosition != lastEncoderPosition) {
            lastEncoderPosition = encoderPosition;
            oled.clear();
            oled.setCursor(2, 0);
            oled.setTextSize(1);
            oled.print("Encoder: ");
           
           oled.setTextSize(1);
            oled.print((int)encoderPosition);
            // Serial.print("\r                          \r");
            //  Serial.print(encoderPosition);
            //  Serial.flush();
            oled.show();
        }
        if (encoderButtonState == RELEASED && lastButtonEncoderState == PRESSED) {
            encoderButtonState = IDLE;
            break;
        }
        if (delayTime < 1) {
            delayTime = 1;
        }
    }
  //  oled.clear();
    //oled.displayBitmap(0, 0, jogo32h, 128, 32);
    oled.show();
    // gpioNet[1] = -1;
    // gpioNet[2] = -1;
    // gpioState[1] = 4;
    // gpioState[2] = 4;
    return 0;
}

const unsigned char ColorJumpLogo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xff, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x02, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0xff, 0xfc, 0x00, 0x00,
    0x00, 0x00, 0x3f, 0x1f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x8f, 0xff, 0xff, 0x80, 0x00,
    0x00, 0x00, 0xfb, 0x8f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0xfb, 0x4f, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x02, 0x30, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x06, 0x00, 0x0f, 0xff, 0xfc, 0x18, 0x00,
    0x00, 0x0c, 0x00, 0x03, 0xff, 0xf8, 0x3c, 0x00, 0x00, 0x0e, 0x00, 0x07, 0xff, 0xf0, 0x7c, 0x00,
    0x00, 0x1c, 0x00, 0x03, 0xff, 0xe0, 0xfe, 0x00, 0x00, 0x10, 0x00, 0x01, 0xff, 0xc1, 0xfe, 0x00,
    0x00, 0x38, 0x00, 0x03, 0xff, 0x83, 0xff, 0x00, 0x00, 0x30, 0x00, 0x01, 0xff, 0x07, 0x0f, 0x00,
    0x00, 0x3c, 0x00, 0x05, 0xfe, 0x0e, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x01, 0xfc, 0x1c, 0x3f, 0x80,
    0x00, 0x7c, 0x00, 0x01, 0xf8, 0x38, 0x7f, 0x80, 0x00, 0x7f, 0x80, 0x01, 0xf0, 0x78, 0x7f, 0x80,
    0x00, 0xff, 0x00, 0x01, 0xe0, 0xfc, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xc1, 0xfc, 0x7f, 0xc0,
    0x3f, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x1f, 0xc0, 0x38, 0x00, 0xec, 0x00, 0x07, 0xfe, 0x1f, 0xc0,
    0x00, 0xff, 0xfe, 0x00, 0x00, 0x7e, 0x1f, 0xc0, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x1e, 0x0f, 0xc0,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x06, 0x0f, 0xc0, 0x00, 0xff, 0xff, 0x80, 0x00, 0x00, 0x0f, 0xc0,
    0x00, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0x80,
    0x00, 0x7f, 0xff, 0x83, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x7f, 0xff, 0x07, 0xc0, 0x00, 0x1f, 0x80,
    0x00, 0x7f, 0xfe, 0x0f, 0xf0, 0x03, 0xff, 0x80, 0x00, 0x3f, 0xfc, 0x1f, 0xf8, 0x01, 0xff, 0x00,
    0x00, 0x3f, 0xf8, 0x3f, 0xfc, 0x00, 0x7f, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xfe, 0x00, 0x0e, 0x00,
    0x00, 0x1f, 0xe0, 0xff, 0xff, 0x80, 0x01, 0x80, 0x00, 0x0f, 0xc1, 0xff, 0xff, 0xe0, 0x01, 0xfe,
    0x00, 0x0f, 0x83, 0xff, 0xff, 0xfc, 0x03, 0xfe, 0x00, 0x07, 0x07, 0xff, 0xff, 0xff, 0xf0, 0xce,
    0x00, 0x02, 0x0f, 0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x01,
    0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xc0, 0x01, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x00,
    0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'Jogo255', 128x64px
const unsigned char jogo255 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xbf, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xbf, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xdf, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xdf, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfb, 0xff, 0xff, 0xfe, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xda, 0x7f, 0xff, 0xfc, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x4f, 0xff, 0xf8, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x6f, 0xff, 0xf1, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x0f, 0xff, 0xe3, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x0f, 0xff, 0xc7, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x0f, 0xff, 0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x0f, 0xff, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x0f, 0xfe, 0x3e, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x07, 0xfc, 0x7c, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x03, 0xf8, 0xf9, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x03, 0xf1, 0xfd, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x60, 0xff, 0x00, 0x01, 0xe3, 0xfd, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x08, 0x00, 0xc7, 0xfe, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xfb, 0xfc, 0x00, 0x0f, 0xfe, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x18, 0xff, 0xfe, 0x00, 0x0f, 0xfe, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x7e, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x3e, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xc7, 0x80, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x8f, 0xe0, 0x08, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x1f, 0xf0, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x3f, 0xf8, 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x7f, 0xfc, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0xff, 0xff, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf1, 0xff, 0xff, 0xc0, 0x03, 0xcc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe3, 0xff, 0xff, 0xf8, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc7, 0xff, 0xff, 0xff, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x8f, 0xff, 0xff, 0xff, 0xf7, 0xde, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1f, 0xff, 0xff, 0xff, 0xf0, 0x0e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'Jogo255', 128x32px
const unsigned char jogo32h [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfb, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x8b, 0xfe, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0xfd, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0xfb, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x03, 0xf7, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x81, 0xee, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x81, 0xde, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x60, 0xbe, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x0e, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfb, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf7, 0xc3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xef, 0xe0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xdf, 0xf8, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xbf, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char ColorJumpLogo32[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xc0, 0x0f, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0xce, 0xff, 0x00, 0x00, 0xc2, 0x7f, 0x00, 
    0x00, 0x80, 0x3f, 0x00, 0x40, 0x80, 0x1f, 0x02, 0x00, 0x80, 0x0f, 0x07, 0x20, 0x00, 0x07, 0x04, 
    0x60, 0x00, 0x03, 0x0e, 0x60, 0x00, 0x21, 0x0f, 0x00, 0x00, 0x30, 0x0e, 0x00, 0x00, 0x70, 0x0c, 
    0xf0, 0x07, 0x00, 0x0c, 0xe0, 0x0f, 0x00, 0x0c, 0xe0, 0x0f, 0x00, 0x0c, 0xe0, 0x87, 0x00, 0x04, 
    0xc0, 0xc3, 0x03, 0x06, 0xc0, 0xe1, 0x07, 0x00, 0x80, 0xf0, 0x1f, 0x68, 0x00, 0xf8, 0xff, 0x01, 
    0x00, 0xfc, 0xff, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char white32[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    
};

// Add this function to scan for I2C addresses

